#!/usr/bin/env python3

"""
A convenience script to extract transactions from PDFs downloaded from us.etrade.com
"""
import ensure_in_venv

import argparse
import csv
from dataclasses import dataclass
import datetime
from decimal import Decimal
from functools import partial
import io
import itertools
from pprint import pprint
import re
import sys
from typing import Any, Optional, Tuple, Union, List

from txlib import AcbCsvRenderer, Action, Tx

import PyPDF2

_debug = False

def debug(*args):
   if _debug:
      print(*args, file=sys.stderr)
      sys.stderr.flush()

def ppdebug(obj):
   if _debug:
      pprint(obj, stream=sys.stderr)
      sys.stderr.flush()

@dataclass
class BenefitEntry:
   security: str

   acquire_tx_date: datetime.date
   acquire_settle_date: datetime.date
   acquire_share_price: Decimal
   acquire_shares: int

   sell_to_cover_tx_date: Optional[datetime.date]
   sell_to_cover_settle_date: Optional[datetime.date]
   sell_to_cover_price: Optional[Decimal]
   sell_to_cover_shares: Optional[int]
   sell_to_cover_fee: Optional[Decimal]

   plan_note: str
   sell_note: Optional[str] = None
   filename: Optional[str] = None

def make_tx_renderer(benefits: List[BenefitEntry]):
   renderer = AcbCsvRenderer()
   for row, b in enumerate(benefits):
      buy_tx = Tx(
            security=b.security,
            trade_date=Tx.date_to_str(b.acquire_tx_date),
            settlement_date=Tx.date_to_str(b.acquire_settle_date),
            trade_date_and_time=Tx.date_to_str(b.acquire_tx_date),
            settlement_date_and_time=Tx.date_to_str(b.acquire_settle_date),
            action=Action.BUY,
            amount_per_share=float(b.acquire_share_price),
            num_shares=b.acquire_shares,
            commission=0.0,
            currency='USD',
            affiliate='',
            row_num=row+1,
            memo=b.plan_note,
            exchange_rate=None,
         )

      renderer.txs.append(buy_tx)

      if b.sell_to_cover_shares is not None:
         sell_note = b.sell_note or "sell-to-cover"
         sell_tx = Tx(
               security=b.security,
               trade_date=Tx.date_to_str(b.sell_to_cover_tx_date),
               settlement_date=Tx.date_to_str(b.sell_to_cover_settle_date),
               trade_date_and_time=Tx.date_to_str(b.sell_to_cover_tx_date),
               settlement_date_and_time=Tx.date_to_str(b.sell_to_cover_settle_date),
               action=Action.SELL,
               amount_per_share=float(b.sell_to_cover_price),
               num_shares=b.sell_to_cover_shares,
               commission=float(b.sell_to_cover_fee),
               currency='USD',
               affiliate='',
               row_num=row+1,
               memo=f"{b.plan_note} {sell_note}",
               exchange_rate=None,
            )

         renderer.txs.append(sell_tx)

   renderer.sort_txs()
   return renderer

class ReSearchError(Exception):
   pass

def search_for_group(
      pattern: str, text: str, flags: int = 0, group: int = 1, optional : bool = True
) -> Optional[Any]: ...

def search_for_group(
      pattern: str, text: str, flags: int = 0, group: int = 1, optional : bool = False
) -> str:
   m = re.search(pattern, text, flags=flags)
   if m:
      return m.group(group)
   else:
      if optional:
         return None
      raise ReSearchError(f"Could not find {repr(pattern)}")

def search_for_decimal(pattern, text, flags=0, group=1, optional=False):
   val_str = search_for_group(pattern, text,
                              flags=flags, group=group, optional=optional)
   if val_str:
      return Decimal(val_str.replace(',', ''))
   return None

def search_for_row(key: str, val_pat: str, text: str) -> List[Any]:
   mainPattern = key + rf"(?:\s+(?P<rowvalue>{val_pat}(?:\s+{val_pat})?))"

   ret = []
   for m in re.finditer(mainPattern, text):
      val = m.group("rowvalue")
      ret += list(re.findall(val_pat, val))
   if not ret:
      raise ReSearchError(f"Could not find {repr(mainPattern)}")
   return ret

def text_to_common_data(text: str) -> dict:
   return {
      "employee id": search_for_group(r"Employee ID:\s*(\d+)", text),
      "account number": search_for_group(r"Account Number\s*(\d+)", text, optional=True),
      "symbol": search_for_group(r"Company Name\s*\(Symbol\)*.*\(([A-Za-z\.]+)\)", text, re.S),
   }

def text_to_rsu_data(text: str) -> dict:
   return text_to_common_data(text) | {
      "release date": datetime.datetime.strptime(
         search_for_group(r"Release Date\s*(\d+-\d+-\d+)", text), "%m-%d-%Y"
      ).date(),
      "award number": search_for_group(r"Award Number\s*(R\d+)", text),
      "share released": search_for_decimal(r"Shares Released\s*(\d+\.\d+)", text),
      "share sold": search_for_decimal(r"Shares Sold\s*\((\d+\.\d+)\)", text),
      "share issued": search_for_decimal(r"Shares Issued\s*(\d+\.\d+)", text),
      "FMV": search_for_decimal(r"Market Value Per Share\s*\$(\d+\.\d+)", text),
      "sale price": search_for_decimal(r"Sale Price Per Share\s*\$(\d+\.\d+)", text),
      "market value": search_for_decimal(r"Market Value\s*\$([\d,]+\.\d+)", text),
      "total sale price": search_for_decimal(r"Total Sale Price\s*\$([\d,]+\.\d+)", text),
      "total tax": search_for_decimal(r"Total Tax\s*\$([\d,]+\.\d+)", text),
      "fee": search_for_decimal(r"Fee\s*\(\$(\d+\.\d+)", text),
      "cash leftover": search_for_decimal(r"Total Due Participant\s*\$(\d+\.\d+)", text),
   }

def text_to_rsu_entry(text: str) -> BenefitEntry:
   data = text_to_rsu_data(text)
   return BenefitEntry(
         security=data['symbol'],

         # The FMV is for the release date, so treat that as the tx date.
         acquire_tx_date=data['release date'],
         # There is no way to know the settlement date in RSU distributions.
         # Since they are never near the year-end boundary, just use the release date.
         acquire_settle_date=data['release date'],
         acquire_share_price=data['FMV'],
         acquire_shares=int(data['share released']),

         # The sell-to-cover date is almost always a day or two after the release
         # date. This needs to be looked up separately if we want an accurate
         # USD/CAD exchange rate.
         sell_to_cover_tx_date=data['release date'],
         sell_to_cover_settle_date=None,
         sell_to_cover_price=data['sale price'],
         sell_to_cover_shares=int(data['share sold']),
         sell_to_cover_fee=data['fee'],

         plan_note="RSU " + data['award number'],
      )

   return text_to_common_data(text) | {
      "purchase date": datetime.datetime.strptime(
         search_for_group(r"Exercise Date:\s*(\d+-\d+-\d+)", text), "%m-%d-%Y"
      ).date(),
      "share purchased": search_for_decimal(r"Shares Purchased\s*(\d+\.\d+)", text),
      "share sold":
         search_for_decimal(r"Shares Sold to Cover Taxes\s*(\d+\.\d+)", text, optional=True),
      "FMV":
         search_for_decimal(r"Purchase Value per Share\s*\$(\d+\.\d+)", text),
      "purchase price":
         search_for_decimal(
            r"Purchase Price per Share\s*\([^\)]*\)\s*\$(\d+\.\d+)", text, re.S
         ),
      "total price": search_for_decimal(r"Total Price\s*\(\$([\d,]+\.\d+)\)", text),
      "total value": search_for_decimal(r"Total Value\s*\$([\d,]+\.\d+)", text),
      "taxable gain": search_for_decimal(r"Taxable Gain\s*\$([\d,]+\.\d+)", text),
      "sale price": search_for_decimal(
            r"Sale Price for Shares Sold to Cover Taxes\s*\$(\d+\.\d+)", text,
            optional=True,
         ),
      "fee": search_for_decimal(r"Fees\s*\(\$(\d+\.\d+)", text, optional=True),
      "total sale price": search_for_decimal(
         r"Value Of Shares Sold\s\$([\d,]+\.\d+)", text, optional=True),
      "market value at grant":
         search_for_decimal(r"Market Value\s*\$([\d,]+\.\d+)", text),
      "cash leftover":
         search_for_decimal(r"Amount in Excess of Tax Due\s\$(\d+\.\d+)", text, optional=True),
      "total tax": search_for_decimal(
         r"Total Taxes Collected at purchase\s\(\$([\d,]+\.\d+)\)", text,
         optional=True),
   }

def text_to_eso_entries(text: str, filename: str) -> List[BenefitEntry]:
   exc_type = search_for_group(r"Exercise Type:\s+(.*)\s+Registration", text)
   ppdebug(text)
   debug("Exercise Type:", exc_type)
   if exc_type != "Same-Day Sale":
      raise Exception(f"Unknown exercise type {exc_type!r}")
   
   entries : List[BenefitEntry] = []
   common = text_to_common_data(text)
   txdate = datetime.datetime.strptime(
      search_for_group(r"Exercise Date:\s+(\d+/\d+/\d+)", text),
      '%m/%d/%Y',
   ).date()

   mbody = re.search("Exercise Details.*Exercise Date", text,re.S)
   assert mbody

   head = text[:mbody.start()]
   text = text[mbody.start():]
   
   grants = re.findall(r"Grant (\d+)", text)
   debug("Grants:", grants)
   
   grant_nums = search_for_row("Grant Number", r"(\d+)", text)
   match = partial(search_for_row, text=text)
   fmvs = match("Exercise Market Value", r"\$(\d+\.\d+)")
   exc_count = match("Shares Exercised", r"\d+")
   sell_count = int(search_for_group(r"Shares Sold\s+([\d,]+)", head).replace(",", ""))
   sell_prices = match("Sale Price", r"\$(\d+\.\d+)")
   fees = match("Comission/Fee", r"\$(\d+\.\d+)")

   debug("sell_count:", sell_count)
   def makeDecimal(v: str) -> Decimal:
      return Decimal(v.replace(",", ""))

   def _equal(v:  List[str]) -> str:
      assert len(set(v)) == 1, f"mismatched values in {v!r}"
      assert len(v) == len(grants), f"v: {v}, grants: {grants}"
      return v[0]

   def _sum(v: List[str]) -> Decimal:
      assert len(v) == len(grants), f"v: {v}, grants: {grants}"
      return sum(map(makeDecimal, v))
   
   ppdebug(grant_nums)
   ppdebug(fmvs)
   for idx, _ in enumerate(grants):
      ent = BenefitEntry(
         security=common['symbol'],
         acquire_tx_date=txdate,
         acquire_settle_date=txdate,
         acquire_share_price=makeDecimal(fmvs[idx]),
         acquire_shares=int(exc_count[idx]),

         sell_to_cover_tx_date=None,
         sell_to_cover_settle_date=None,
         sell_to_cover_price=None,
         sell_to_cover_shares=None,
         sell_to_cover_fee=None,
         
         plan_note=f"Option Grant {grant_nums[idx]}",
         sell_note=exc_type,
         filename=filename,
      )
      if idx == len(grant_nums) - 1:
         ent.sell_to_cover_tx_date = txdate
         ent.sell_to_cover_settle_date = txdate
         ent.sell_to_cover_price = makeDecimal(_equal(sell_prices))
         ent.sell_to_cover_shares = sell_count
         ent.sell_to_cover_fee = _sum(fees)
      entries.append(ent)
      
      
   return entries

def text_to_espp_data(text) -> dict:
   return text_to_common_data(text) | {
      "purchase date": datetime.datetime.strptime(
         search_for_group(r"Purchase Date\s*(\d+-\d+-\d+)", text), "%m-%d-%Y"
      ).date(),
      "share purchased": search_for_decimal(r"Shares Purchased\s*(\d+\.\d+)", text),
      "share sold":
         search_for_decimal(r"Shares Sold to Cover Taxes\s*(\d+\.\d+)", text, optional=True),
      "FMV":
         search_for_decimal(r"Purchase Value per Share\s*\$(\d+\.\d+)", text),
      "purchase price":
         search_for_decimal(
            r"Purchase Price per Share\s*\([^\)]*\)\s*\$(\d+\.\d+)", text, re.S
         ),
      "total price": search_for_decimal(r"Total Price\s*\(\$([\d,]+\.\d+)\)", text),
      "total value": search_for_decimal(r"Total Value\s*\$([\d,]+\.\d+)", text),
      "taxable gain": search_for_decimal(r"Taxable Gain\s*\$([\d,]+\.\d+)", text),
      "sale price": search_for_decimal(
            r"Sale Price for Shares Sold to Cover Taxes\s*\$(\d+\.\d+)", text,
            optional=True,
         ),
      "fee": search_for_decimal(r"Fees\s*\(\$(\d+\.\d+)", text, optional=True),
      "total sale price": search_for_decimal(
         r"Value Of Shares Sold\s\$([\d,]+\.\d+)", text, optional=True),
      "market value at grant":
         search_for_decimal(r"Market Value\s*\$([\d,]+\.\d+)", text),
      "cash leftover":
         search_for_decimal(r"Amount in Excess of Tax Due\s\$(\d+\.\d+)", text, optional=True),
      "total tax": search_for_decimal(
         r"Total Taxes Collected at purchase\s\(\$([\d,]+\.\d+)\)", text,
         optional=True),
   }

def text_to_espp_entry(text: str) -> BenefitEntry:
   data = text_to_espp_data(text)
   return BenefitEntry(
         security=data['symbol'],

         acquire_tx_date=data['purchase date'],
         # There is no way to know the settlement date in ESPP distributions.
         # Since they are never near the year-end boundary, just use the purchase date.
         acquire_settle_date=data['purchase date'],
         acquire_share_price=data['FMV'],
         acquire_shares=int(data['share purchased']),

         # The sell-to-cover date is almost always a day or two after the release
         # date. This needs to be looked up separately if we want an accurate
         # USD/CAD exchange rate.
         sell_to_cover_tx_date=None,
         sell_to_cover_settle_date=None,
         sell_to_cover_price=data['sale price'],
         sell_to_cover_shares=int(data['share sold']) if data['share sold'] else None,
         sell_to_cover_fee=data['fee'],

         plan_note="ESPP",
      )

@dataclass
class TradeConfirmation:
   security: str
   action: str
   tx_date: datetime.date
   settle_date: datetime.date
   shares: int
   price: Optional[Decimal] = None
   principal: Optional[Decimal] = None
   commission: Optional[Decimal] = None
   finra_taf: Optional[Decimal] = None
   fee: Optional[Decimal] = None
   fee_total: Decimal = Decimal(0)

   def __hash__(self):
      return hash(repr(self))

def text_to_trade_confirmation_objs(text: str):
   def maybeDecimal(v: Optional[str]) -> Optional[Decimal]:
      if v is None:
         return None
      return Decimal(v.replace(",", ""))

   info = re.compile(r'(?P<txdate>\d+/\d+/\d+)\s+(?P<sdate>\d+/\d+/\d+)\s+(?P<cpt>\d+)\s+'
                    r'(?P<sym>\S+)\s+(?P<act>\S+)\s+(?P<nshares>[,\d]+)\s+\$(?P<price>\d+\.\d+)\s+'
                    r'.*'
                    r'PRINCIPAL\s+\$(?P<principal>[\d,]+\.\d+)'
                    r'(?P<remainder>.*)')
   comm = re.compile(r'.*\s+COMMISSION\s+\$(?P<value>[\d,]+\.\d+)')
   taf = re.compile(r'.*\s+FINRA TAF\s+\$(?P<value>[\d,]+\.\d+)')
   fee = re.compile(r'(?:.+\s+)?FEE\s*[\$]?(?P<value>[\d,]+\.\d+)')
   objs: List[TradeConfirmation] = []
   lines = text.splitlines()
   ppdebug(lines)
   for num, line in enumerate(lines):
      if m := info.match(line):
         obj = TradeConfirmation(
            security=m.group('sym'),
            action=m.group('act'),
            tx_date=datetime.datetime.strptime(m.group('txdate'), '%m/%d/%y').date(),
            settle_date=datetime.datetime.strptime(m.group('sdate'), '%m/%d/%y').date(),
            shares=int(maybeDecimal(m.group('nshares')) or 999999),
            price=Decimal(m.group('price')),
            principal=maybeDecimal(m.group('principal')),
         )
         detailLines = lines[num:num+4]
         for detail in detailLines:
            if m := comm.match(detail):
               obj.commission = maybeDecimal(m.group('value'))
            elif m := taf.match(detail):
               obj.finra_taf = maybeDecimal(m.group('value'))
            elif m := fee.match(detail):
               obj.fee = maybeDecimal(m.group('value'))
         if obj.fee is None:
            raise Exception("missing fee\n" + repr(detailLines))
         obj.fee_total = (
            obj.fee
            + (obj.commission or 0)
            + (obj.finra_taf or 0)
         )
         objs.append(obj)

   assert objs
   return objs

def parse_pdf(f: io.BufferedReader) -> Union[List[BenefitEntry], List[TradeConfirmation]]:
   reader = PyPDF2.PdfReader(f)
   text = reader.pages[0].extract_text()

   if re.search(r'STOCK\s+PLAN\s+RELEASE\s+CONFIRMATION', text):
      obj = [text_to_rsu_entry(text)]
   elif re.search(r'STOCK\s+PLAN\s+EXERCISE\s+CONFIRMATION', text):
      obj = text_to_eso_entries(text, str(f.name))
   elif re.search(r'Plan\s*(2014|ESP2)', text):
      obj = [text_to_espp_entry(text)]
   elif re.search(r'TRADE\s*CONFIRMATION', text):
      debug("trade confirmation")
      obj = text_to_trade_confirmation_objs(text)
   else:
      pprint(text, stream=sys.stderr)
      print(f"Error: {f.name!r} Unrecognized PDF format", file=sys.stderr)
      exit(1)

   ppdebug(obj)
   return obj

def find_and_apply_sell_to_cover_trade_set(benefit: BenefitEntry, trade_confs: List[TradeConfirmation]):
   matching_trades = None
   errors = []
   for n in range(len(trade_confs), 0, -1):
      for trades in itertools.combinations(trade_confs, n):
         if not all(t.security == benefit.security for t in trades):
            continue
         n_shares = sum(t.shares for t in trades)
         if n_shares == benefit.sell_to_cover_shares:
            if matching_trades is not None:
               if set(matching_trades) != set(trades):
                  errors.append(f"Error: Multiple trade combinations near {benefit.acquire_tx_date} "
                                f"could potentially constitute the sale {benefit.filename}")
                  matching_trades = None
                  break
               # If these are basically equivalent sets of trades, just skip.
               # This is most likely to happen when multiple sells get split into X and 1.
            else:
               matching_trades = trades

   if not matching_trades and errors:
      for e in errors:
         print(e, file=sys.stderr)
      return []

   if matching_trades:
      matching_trades = sorted(matching_trades, key=lambda t: t.tx_date)
      t0 = matching_trades[0]
      for t in matching_trades[1:]:
         if t.tx_date != t0.tx_date or t.settle_date != t0.settle_date:
            print("Warning: sell-to-cover trades have varrying dates:",
                  file=sys.stderr)
            for t_ in matching_trades:
               pprint(t_, stream=sys.stderr)
      benefit.sell_to_cover_tx_date=t0.tx_date
      benefit.sell_to_cover_settle_date=t0.settle_date
      return matching_trades
   else:
      print(f"Error: Found no trades matching the sell-to-cover for {benefit.acquire_tx_date} {benefit.filename}", file=sys.stderr)
      return []

def amend_benefit_sales(benefits: List[BenefitEntry], trade_confs: List[TradeConfirmation]):
   trade_confs = list(trade_confs) # Make a a copy
   for benefit in benefits:
      # Find the sale(s) which could constitute this sell-to-cover
      latest_day = benefit.acquire_tx_date + datetime.timedelta(days=5)
      candidate_trades = []
      for trade in trade_confs:
         if trade.action == 'SELL' and \
            benefit.acquire_tx_date <= trade.tx_date and trade.tx_date <= latest_day:
            candidate_trades.append(trade)

      if benefit.sell_to_cover_shares:
         matched_trades = find_and_apply_sell_to_cover_trade_set(benefit, candidate_trades)
         for t in matched_trades:
            trade_confs.remove(t)

   # Return leftover trades
   return trade_confs

def main():
   ap = argparse.ArgumentParser(description="""\
Instructions:
Go to us.etrade.com, log into your account, and go to 'Stock Plan', then to
'Holdings'. In ESPP and RS sections, click 'Benefit History'. Expand each relevant
section, and donwload (right-click and 'save link as') each
'View confirmation of purchase' or 'View confirmation of release' link PDF.

Then go to 'Account', then 'Documents' > 'Trade Confirmations.' Adjust the date
range, and download the trade confirmation PDF for each sale.
Note: For sales on the same day, both appear on the same PDF. The download link
for both sales is to the same document, so only one needs to be downloaded.

Run this script, giving the name of all PDFs as arguments.""",
         formatter_class=argparse.RawDescriptionHelpFormatter,)
   ap.add_argument('files', metavar='FILES', nargs='+')
   ap.add_argument('--pretty', action='store_true')
   ap.add_argument('--debug', action='store_true')
   ap.add_argument('--extract-only', action='store_true')
   args = ap.parse_args()

   global _debug
   _debug = args.debug

   benefits: List[BenefitEntry] = []
   trade_confs: List[TradeConfirmation] = []
   first = True
   for fname in args.files:
      if not first:
         debug()
      first = False
      debug("Parsing ", fname)
      with open(fname, 'rb') as f:
         try:
            obj = parse_pdf(f)
            if isinstance(obj, list):
               for o in obj:
                  if isinstance(o, BenefitEntry):
                     benefits.append(o)
                  elif isinstance(o, TradeConfirmation):
                     trade_confs.append(o)
                  else:
                     raise Exception(f"Bad PDF type {o}")
         except (ReSearchError, Exception) as e:
            print(f"Error parsing {fname}: {e}", file=sys.stderr)
            raise

   if args.extract_only:
      for desc, c in (
            ("trades", trade_confs),
            ("benefits", benefits),
      ):
         header: Optional[List[str]] = None
         rows: List[List[str]] = []
         for t in c:
            if header is None:
               header = list(t.__match_args__)
            rows.append([getattr(t, k) for k in header])
         if header is None:
            print("WARN: No", desc, "entries", file=sys.stderr)
            continue
         sys.stdout.flush()
         writer = csv.writer(sys.stdout, delimiter=',', quoting=csv.QUOTE_MINIMAL)
         writer.writerow(header)
         for row in rows:
            writer.writerow(row)
      return

   remaining_trades = amend_benefit_sales(benefits, trade_confs)
   debug("\nAmmended benefit entries:")
   for b in benefits:
      ppdebug(b)
   debug("\nRemaining trades:")
   for t in remaining_trades:
      ppdebug(t)

   debug("\nTable:")
   renderer = make_tx_renderer(benefits)
   if args.pretty:
      renderer.render_table()
   else:
      renderer.render_csv()

if __name__ == '__main__':
   exit(main())
